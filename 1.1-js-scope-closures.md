# Notes from "Yo don't know JS yet: Scopes and Closures"

## 1 - What is Scope and some definitions

***Scope:***

Are well-defined rules with which JS knows what variables are accessible by an statement, block or function. 


JS code is parsed before execution in order to decide where to place variables, functions and blocks according to scope rules.

***Closures:***

In JS functions can be passed around just like any other value (first class objects). But functions themselves can hold and access values. So, the rules about what scope a function mantains no matter where the function is finally executed, are called ***closures***.

The fact that we can consider JS as a compiled language (or at least, a parsed one) is crucial to understanding scoping and closures.

***Lexical Scope***

In the compilation phase a map is created, of all the lexical scopes that the program will need while is executed.

This doesn't mean that compilation reserves memory, that doesn't happen until the program is executed.

The scopes are controlled entirely by the placement of functions, blocks, and variable declarations, in relation to one another.

Each scope gets its own Scope Manager instance each time that scope is executed (one or more times). Each scope automatically has all its identifiers registered at the start of the scope being executed (this is called “variable hoisting”)

***Nesting of scopes***

One of the key aspects of lexical scope is that any time an identifier reference cannot be found in the current scope, the next outer scope in the nesting is consulted; that process is repeated until an answer is found or there are no more scopes to consult.

Undefined is not the same as "not defined"

## Closures

---
Possible points:

- Definition of scope
- Some definitions
- JS Compile cycle
- Lexical scope (parts)
- Scope chain
- Functions vs. Arrow functions
- Global scope
- Variables: hoisting
- Undeclared and redeclared
- Scoping and limiting scope
- Closures
- Module pattern
- CommonJS
- ESM modules
